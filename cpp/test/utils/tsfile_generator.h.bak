/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * License); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License a
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
#include <gtest/gtest.h>

#include <fstream>
#include <iostream>
#include <locale>
#include <random>
#include <string>
#include <vector>

#include "file/write_file.h"

using namespace common;
using namespace storage;

class TsFileGeneratorForTest : public ::testing::Test {
   protected:
    static const long kStartTimestamp = 1480562618000L;
    static std::string input_data_file_;
    static std::string output_data_file_;
    static std::string aligned_output_data_file_;
    static std::string error_output_data_file_;
    static int row_count_;
    static int chunk_group_size_;
    static int page_size_;
    static FSFactory fs_factory_;

    static std::string get_test_tsfile_path(
        const std::string& logical_storage_group_name,
        long virtual_storage_group_id, long time_partition_id,
        long ts_file_version) {
        char buffer[256];
        std::sprintf(buffer, TestConstant::kTestTsFilePath.c_str(),
                     logical_storage_group_name.c_str(),
                     virtual_storage_group_id, time_partition_id);
        return TsFileGeneratorUtils::GetTsFilePath(buffer, ts_file_version);
    }

    static void generate_file(int row_count, int chunk_group_size,
                              int page_size) {
        generate_file(row_count, row_count, chunk_group_size, page_size);
    }

    static void generate_file(int min_row_count, int max_row_count,
                              int chunk_group_size, int page_size) {
        row_count_ = max_row_count;
        chunk_group_size_ = chunk_group_size;
        page_size_ = page_size;
        prepare(min_row_count, max_row_count);
        write();
    }

    static void prepare(int min_row_count, int max_row_count) {
        auto file = fs_factory_.GetFile(output_data_file_);
        if (!file->ParentExists()) {
            ASSERT_TRUE(file->MakeParentDir());
        }
        input_data_file_ = get_test_tsfile_path("root.sg1", 0, 0, 1);
        file = fs_factory_.GetFile(input_data_file_);
        if (!file->ParentExists()) {
            ASSERT_TRUE(file->MakeParentDir());
        }
        error_output_data_file_ = get_test_tsfile_path("root.sg1", 0, 0, 2);
        file = fs_factory_.GetFile(error_output_data_file_);
        if (!file->ParentExists()) {
            ASSERT_TRUE(file->MakeParentDir());
        }
        GenerateSampleInputDataFile(min_row_count, max_row_count);
    }

    static void After() {
        auto file = fs_factory_.GetFile(input_data_file_);
        if (file->Exists()) {
            ASSERT_TRUE(file->Remove());
        }
        file = fs_factory_.GetFile(output_data_file_);
        if (file->Exists()) {
            ASSERT_TRUE(file->Remove());
        }
        file = fs_factory_.GetFile(error_output_data_file_);
        if (file->Exists()) {
            ASSERT_TRUE(file->Remove());
        }
    }

    static void GenerateSampleInputDataFile(int min_row_count,
                                            int max_row_count) {
        auto file = fs_factory_.GetFile(input_data_file_);
        if (file->Exists()) {
            ASSERT_TRUE(file->Remove());
        }
        file->MakeParentDir();

        std::ofstream fw(file->GetPath());
        long start_time = kStartTimestamp;
        for (int i = 0; i < max_row_count; ++i) {
            std::string d1 = "d1," + std::to_string(start_time + i) + ",s1," +
                             std::to_string(i * 10 + 1) + ",s2," +
                             std::to_string(i * 10 + 2);
            if (i % 5 == 0) d1 += ",s3," + std::to_string(i * 10 + 3);
            if (i % 8 == 0) d1 += ",s4,dog" + std::to_string(i);
            if (i % 9 == 0) d1 += ",s5,false";
            if (i % 10 == 0 && i < min_row_count)
                d1 += ",s6," +
                      std::to_string(static_cast<int>(i / 9.0 * 100) / 100.0);
            if (i % 11 == 0)
                d1 += ",s7," +
                      std::to_string(static_cast<int>(i / 10.0 * 100) / 100.0);
            fw << d1 << "\r\n";

            std::string d2 = "d2," + std::to_string(start_time + i) + ",s2," +
                             std::to_string(i * 10 + 2) + ",s3," +
                             std::to_string(i * 10 + 3);
            if (i % 20 < 5)
                d2 = "d2," + std::to_string(start_time + i) + ",s2,,s3," +
                     std::to_string(i * 10 + 3);
            if (i % 5 == 0) d2 += ",s1," + std::to_string(i * 10 + 1);
            if (i % 8 == 0) d2 += ",s4,dog0";
            fw << d2 << "\r\n";
        }

        std::string d = "d2,3," + std::to_string(start_time + row_count_) +
                        ",s2," + std::to_string(row_count_ * 10 + 2) + ",s3," +
                        std::to_string(row_count_ * 10 + 3);
        fw << d << "\r\n";
        d = "d2," + std::to_string(start_time + row_count_ + 1) + ",2,s-1," +
            std::to_string(row_count_ * 10 + 2);
        fw << d << "\r\n";
    }

    static void write() {
        auto file = fs_factory_.GetFile(output_data_file_);
        auto error_file = fs_factory_.GetFile(error_output_data_file_);
        if (file->Exists()) {
            ASSERT_TRUE(file->Remove());
        }
        if (error_file->Exists()) {
            ASSERT_TRUE(error_file->Remove());
        }

        auto schema = GenerateTestSchema();

        auto old_group_size_in_byte =
            TSFileDescriptor::GetInstance()->GetConfig().GetGroupSizeInByte();
        auto old_max_point_num_in_page = TSFileDescriptor::GetInstance()
                                             ->GetConfig()
                                             .GetMaxNumberOfPointsInPage();
        TSFileDescriptor::GetInstance()->GetConfig().SetGroupSizeInByte(
            chunk_group_size_);
        TSFileDescriptor::GetInstance()->GetConfig().SetMaxNumberOfPointsInPage(
            page_size_);

        // write
        try {
            TsFilewriter inner_writer(
                file, schema, TSFileDescriptor::GetInstance()->GetConfig());
            std::ifstream in(input_data_file_);
            std::string str;
            while (std::getline(in, str)) {
                auto record = RecordUtils::ParseSimpleTupleRecord(str, schema);
                inner_writer.write(record);
            }
        } catch (const writeProcessException& e) {
            std::cerr << e.what() << std::endl;
        } finally {
            TSFileDescriptor::GetInstance()
                ->GetConfig()
                .SetMaxNumberOfPointsInPage(old_max_point_num_in_page);
            TSFileDescriptor::GetInstance()->GetConfig().SetGroupSizeInByte(
                old_group_size_in_byte);
        }
    }

    static Schema GenerateTestSchema() {
        Schema schema;
        schema.RegisterTimeseries(Path("d1"),
                                  MeasurementSchema("s1", INT32, RLE));
        schema.RegisterTimeseries(Path("d1"),
                                  MeasurementSchema("s2", INT64, PLAIN));
        schema.RegisterTimeseries(Path("d1"),
                                  MeasurementSchema("s3", INT64, TS_2DIFF));
        schema.RegisterTimeseries(
            Path("d1"), MeasurementSchema("s4", TEXT, PLAIN, UNCOMPRESSED));
        schema.RegisterTimeseries(Path("d1"),
                                  MeasurementSchema("s5", BOOLEAN, RLE));
        schema.RegisterTimeseries(Path("d1"),
                                  MeasurementSchema("s6", FLOAT, RLE, SNAPPY));
        schema.RegisterTimeseries(
            Path("d1"),
            MeasurementSchema("s7", TSDataType::kDouble, TSEncoding::kGorilla));
        schema.RegisterTimeseries(
            Path("d2"),
            MeasurementSchema("s1", TSDataType::kInt32, TSEncoding::kRle));
        schema.RegisterTimeseries(
            Path("d2"),
            MeasurementSchema("s2", TSDataType::kInt64, TSEncoding::kPlain));
        schema.RegisterTimeseries(
            Path("d2"),
            MeasurementSchema("s3", TSDataType::kInt64, TSEncoding::kTs2diff));
        schema.RegisterTimeseries(
            Path("d2"),
            MeasurementSchema("s4", TSDataType::kText, TSEncoding::kPlain,
                              CompressionType::kUncompressed,
                              {{Encoder::kMaxStringLength, "20"}}));
        return schema;
    }

    static void writeFileWithOneIncompleteChunkHeader(
        const std::string& file_path) {
        TsFilewriter writer(fs_factory_.GetFile(file_path));
        ChunkHeader header("s1", 100, TSDataType::kFloat,
                           CompressionType::kSnappy, TSEncoding::kPlain, 5);
        ByteBuffer buffer(header.GetSerializedSize());
        header.SerializeTo(buffer);
        buffer.Flip();
        std::vector<char> data(3);
        buffer.Get(data.data(), 0, 3);
        writer.GetIOwriter()->GetIOwriterOut()->write(data.data(), 3);
        writer.GetIOwriter()->Close();
    }

    static void GenerateAlignedTsFile(int row_count, int chunk_group_size,
                                      int page_size) {
        auto file = fs_factory_.GetFile(aligned_output_data_file_);
        if (file->Exists()) {
            ASSERT_TRUE(file->Remove());
        }
        file->MakeParentDir();

        auto old_group_size_in_byte =
            TSFileDescriptor::GetInstance()->GetConfig().GetGroupSizeInByte();
        auto old_max_point_num_in_page = TSFileDescriptor::GetInstance()
                                             ->GetConfig()
                                             .GetMaxNumberOfPointsInPage();
        TSFileDescriptor::GetInstance()->GetConfig().SetGroupSizeInByte(
            chunk_group_size);
        TSFileDescriptor::GetInstance()->GetConfig().SetMaxNumberOfPointsInPage(
            page_size);
        try {
            TsFilewriter ts_file_writer(file);
            std::vector<MeasurementSchema> aligned_measurement_schemas = {
                MeasurementSchema("s1", TSDataType::kInt64, TSEncoding::kPlain,
                                  CompressionType::kLz4),
                MeasurementSchema("s2", TSDataType::kInt64, TSEncoding::kPlain,
                                  CompressionType::kSnappy),
                MeasurementSchema("s3", TSDataType::kInt64, TSEncoding::kPlain,
                                  CompressionType::kGzip),
                MeasurementSchema("s4", TSDataType::kInt64, TSEncoding::kRle)};
            ts_file_writer.RegisterAlignedTimeseries(
                Path("d1"), aligned_measurement_schemas);

            std::vector<MeasurementSchema> measurement_schemas = {
                MeasurementSchema("s1", TSDataType::kInt64, TSEncoding::kPlain,
                                  CompressionType::kLz4),
                MeasurementSchema("s2", TSDataType::kInt64, TSEncoding::kPlain,
                                  CompressionType::kSnappy),
                MeasurementSchema("s3", TSDataType::kInt64, TSEncoding::kPlain,
                                  CompressionType::kSnappy)};
            ts_file_writer.RegisterTimeseries(Path("d2"), measurement_schemas);

            TsFileGeneratorUtils::writeWithTsRecord(ts_file_writer, "d1",
                                                    aligned_measurement_schemas,
                                                    row_count, 0, 0, true);
            TsFileGeneratorUtils::writeWithTsRecord(ts_file_writer, "d2",
                                                    measurement_schemas,
                                                    row_count, 0, 0, false);
        } catch (const std::exception& e) {
            std::cerr << e.what() << std::endl;
        } finally {
            TSFileDescriptor::GetInstance()
                ->GetConfig()
                .SetMaxNumberOfPointsInPage(old_max_point_num_in_page);
            TSFileDescriptor::GetInstance()->GetConfig().SetGroupSizeInByte(
                old_group_size_in_byte);
        }
    }

    static void CloseAlignedTsFile() {
        auto file = fs_factory_.GetFile(aligned_output_data_file_);
        if (file->Exists()) {
            ASSERT_TRUE(file->Remove());
        }
    }
};

std::string TsFileGeneratorForTest::input_data_file_;
std::string TsFileGeneratorForTest::output_data_file_ =
    TsFileGeneratorForTest::get_test_tsfile_path("root.sg1", 0, 0, 0);
std::string TsFileGeneratorForTest::aligned_output_data_file_ =
    TsFileGeneratorForTest::get_test_tsfile_path("root.sg2", 0, 0, 0);
std::string TsFileGeneratorForTest::error_output_data_file_;
int TsFileGeneratorForTest::row_count_;
int TsFileGeneratorForTest::chunk_group_size_;
int TsFileGeneratorForTest::page_size_;
FSFactory TsFileGeneratorForTest::fs_factory_;

TEST_F(TsFileGeneratorForTest, generate_fileTest) {
    generate_file(100, 128 * 1024 * 1024, 64 * 1024);
    // Add assertions to verify the generated file
    After();
}

TEST_F(TsFileGeneratorForTest, GenerateAlignedTsFileTest) {
    GenerateAlignedTsFile(100, 128 * 1024 * 1024, 64 * 1024);
    // Add assertions to verify the generated file
    CloseAlignedTsFile();
}